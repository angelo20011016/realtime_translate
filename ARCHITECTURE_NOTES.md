# 專案核心架構筆記：WebSocket 與即時通訊

這份文件旨在解釋 `realtime_translate` 專案中，實現即時雙向通訊的核心技術與架構。

## 1. WebSocket 基礎概念

傳統網站使用的 HTTP 協議是一種「請求-回應」模型，而 WebSocket 提供了一種持久化的全雙工通訊通道。

### 傳統 HTTP：寄信模式

- **單向請求**：只有客戶端（瀏覽器）可以發起請求，伺服器只能被動回應。
- **無狀態**：每個請求都是獨立的，伺服器不會記住你上一次的請求。
- **好處**：簡單、通用，適用於獲取網頁、圖片等資源。
- **限制**：伺服器無法主動推送資訊給客戶端，不適合需要高頻率、低延遲互動的場景（如聊天、遊戲、即時儀表板）。

### WebSocket：電話模式

- **雙向通訊 (Full-Duplex)**：一旦連線建立，客戶端和伺服器都可以隨時、主動地向對方發送訊息。
- **持久化連線 (Persistent)**：連線一旦建立，會一直保持開啟狀態，直到一方明確關閉，免去了重複建立連線的開銷。
- **好處**：低延遲、高效率，非常適合本專案中的即時語音串流和翻譯結果推送。

---

## 2. 精準訊息投遞機制

我們如何確保訊息（例如，翻譯結果）只發送給特定房間內的特定使用者？這主要依賴 `flask-socketio` 函式庫提供的兩個核心概念：`Session ID (sid)` 和 `Room`。

### 第一步：連線身分證 (Session ID - `sid`)

- 當任何一個瀏覽器分頁與後端建立 WebSocket 連線時，`SocketIO` 伺服器會為這個獨一無二的連線分配一個 **Session ID**（簡稱 `sid`）。
- `sid` 是這條「電話線路」的唯一識別碼。

### 第二步：通訊錄 (`src/client_manager.py`)

- 為了管理誰是誰，專案使用 `src/client_manager.py` 檔案中的全域字典（如 `rooms`, `clients`）作為一個伺服器端的「通訊錄」。
- 當使用者加入一個房間時，程式會記錄下「哪個 `sid` 對應哪個使用者，並且在哪个房間裡」。
- 例如，`rooms['room_123']` 這個列表可能包含 `[sid_of_user_A, sid_of_user_B]`。

### 第三步：訊息操作員 (`src/socket_handlers.py`)

- 這是處理所有即時通訊邏輯的核心檔案。
- 當來自某個 `sid` 的事件（例如，`audio_data`）觸發時，此檔案中的處理函式會被執行。
- 函式會根據傳入的 `sid`，去「通訊錄」(`client_manager.py`) 中查詢該使用者所在的房間 (`room`)。

### 第四步：指定房間發送 (`emit`)

- 在處理完邏輯後（例如，從 Azure 和 Gemini 獲取了翻譯結果），程式會呼叫 `flask-socketio` 的 `emit` 函式來發送訊息。
- 關鍵在於使用了 `room` 參數：
  ```python
  # 偽代碼，出自 src/socket_handlers.py
  emit('final_result', {'text': '翻譯結果'}, room=user_room)
  ```
- 這行程式碼告訴 `SocketIO`：「請只將這條訊息發送給 `user_room` 這個房間內的所有 `sid`」。
- 如此一來，訊息就被精準地投遞給了正確的接收者，而不會影響到其他房間的使用者。

---

## 3. 安全性：如何加密 WebSocket

一個常見的誤解是 WebSocket 不安全。事實上，與 HTTP 一樣，WebSocket 也有加密和未加密兩種協議。

- **`ws://` (WebSocket)**：未加密的明文傳輸，類似 `http://`。**不應該在生產環境中使用。**
- **`wss://` (WebSocket Secure)**：使用 **TLS/SSL** 加密的安全傳輸，類似 `https://`。**是生產環境的標準。**

### 生產環境的標準架構 (Reverse Proxy)

為了啟用 `wss://` 並提升安全性，標準做法是使用 **Nginx** 這類的反向代理伺服器。

```
                       |                                    |
  [使用者瀏覽器] <-----> | wss:// (TLS 加密通訊) <-----> [Nginx 伺-服器] | <-----> ws:// (內網未加密通訊) <-----> [Flask 應用]
                       |                                    |
  外部公共網路          |          伺服器邊界                   |              安全的內部網路
```

1.  **外部加密**：使用者瀏覽器與 Nginx 之間的所有通訊（`https://` 和 `wss://`）都經過 TLS 加密。
2.  **內部解密**：Nginx 接收到加密流量後，將其解密，然後透過一個快速、低延遲的內部網路將未加密的 `ws://` 流量轉發給後端的 Flask 應用。
3.  **安全邊界**：Flask 應用本身不需要處理複雜的 SSL/TLS 憑證和加解密，它只需要專注於業務邏輯。所有的加密工作都由 Nginx 在安全邊界上完成。

### 結論

只要在生產環境中正確部署了 Nginx 並設定了 TLS 憑證，從使用者到您伺服器的所有 WebSocket 通訊（包含敏感的音訊和文字）都是**完全加密和安全的**。

---

## 4. 總結與下一步

- **WebSocket** 提供了實現即時通訊的持久化雙向通道。
- 伺服器透過 **`sid`** 和 **`room`** 機制來管理使用者並精準投遞訊息。
- 在生產環境中，透過 **`wss://`** 和**反向代理**來確保通訊安全。

接下來，我們建議打開 **`src/socket_handlers.py`** 檔案，來親眼看看上述概念是如何在程式碼中被具體實現的。
